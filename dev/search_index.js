var documenterSearchIndex = {"docs":
[{"location":"tutorials/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/tutorial/#Introduction","page":"Tutorial","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we're going to explore how to use SelectedInversion.jl to compute the selected inverse of two different sparse symmetric positive definite matrices.","category":"page"},{"location":"tutorials/tutorial/#Problem-setup","page":"Tutorial","title":"Problem setup","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"We're going to grab two matrices from the SuiteSparse matrix collection. Refer to the website for more information on these matrices and where they came from.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Feel free to skip ahead, as this part is not related directly to SelectedInversion.jl.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"using MatrixMarket, SuiteSparseMatrixCollection\n\nmat_names = [\"494_bus\", \"parabolic_fem\"]\nssmc = ssmc_db()\nmats_df = ssmc[ssmc.name.∈Ref(mat_names), :]\npaths = fetch_ssmc(mats_df, format = \"MM\")\npaths = [joinpath(path, \"$(mats_df.name[i]).mtx\") for (i, path) in enumerate(paths)]\nA = MatrixMarket.mmread(paths[1]) # 494_bus\nB = MatrixMarket.mmread(paths[2]) # parabolic_fem\nsize(A), size(B)","category":"page"},{"location":"tutorials/tutorial/#SelInv","page":"Tutorial","title":"SelInv","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"We're going to start by tackling the smaller of the two matrices.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"A","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's compute the selected inverse of A.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"using SelectedInversion\nZ, p = selinv(A)\nZ","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the nonzero entries of Z correspond to entries in inv(A).","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"p is a permutation vector. Sparse Cholesky factorizations reorder the rows and columns of a matrix to reduce fill-in in the Cholesky factor. selinv computes its entries according to this permutation.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Concretely, this means that if we want to get a specific entry of the inverse, we need to apply the correct permutation first.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"To test this, we're going to compute the dense full inverse. This is still feasible for such a small matrix, but not recommended in general.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"A_inv = inv(Array(A))","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare the values of Z and A_inv at some arbitrary index. They're not going to match:","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"A_inv[42, 172], Z[42, 172]","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"But if we permute Z first, they do match:","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"A_inv[42, 172], Z[invperm(p), invperm(p)][42, 172]","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"If your use case calls for this kind of depermuted access, you can make life easier with the depermute keyword:","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Z, _ = selinv(A; depermute = true)\nZ","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the nonzero entries of Z directly give you the corresponding entries of inv(A).","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"A_inv[42, 172], Z[42, 172]","category":"page"},{"location":"tutorials/tutorial/#Supernodal-setting","page":"Tutorial","title":"Supernodal setting","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, let's tackle the bigger of the two matrices.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"B","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"We could directly apply selinv to B. But if we have access to a Cholesky factorization of B, we can pass that to selinv instead, which is going to be faster because selinv would have computed a Cholesky internally anyways.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"So just to prove a point, let's first compute a Cholesky factorization:","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearAlgebra\nC = cholesky(B)","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"As we can see, this is a supernodal Cholesky factorization. Supernodal factorizations chunk contiguous columns with an identical sparsity pattern. Computations may then leverage BLAS for these chunks, which can speed things up quite a lot.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"SelInv also uses the supernodal structure internally. As a result, the return type of Z is now different. Let's compute the selected inverse.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Z, p = selinv(C; depermute = true)\nZ","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Z is now a SupernodalMatrix, which is a custom type defined in SelectedInversion.jl.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"It's a subtype of AbstractMatrix, so you can index into it as you would expect. Let's check the value of some arbitrary entry.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"e5 = zeros(size(B, 2))\ne5[5] = 1.0\n(B\\e5)[end], Z[end, 5]","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"The diagonal might be particularly relevant to some applications:","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"diag(Z)","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"It's also possible to convert Z into a sparse matrix. But this is fairly slow and eats up a lot of memory. As such, it should be avoided unless it's truly necessary.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"using SparseArrays\nsparse(Z)","category":"page"},{"location":"tutorials/tutorial/#Conclusion","page":"Tutorial","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"SelectedInversion.jl lets you compute the selected inverse of a sparse symmetric positive definite matrix efficiently. Where applicable, it makes use of supernodal factorizations and thus scales to matrices with more than a million columns.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"As of now, it does not support unsymmetric matrices and does not explicitly make use of parallelization along the elimination tree. If you're interested in helping develop these features, feel free to open an issue or a pull request on GitHub.","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"supernodal_matrix/#SupernodalMatrix-API","page":"SupernodalMatrix","title":"SupernodalMatrix API","text":"","category":"section"},{"location":"supernodal_matrix/","page":"SupernodalMatrix","title":"SupernodalMatrix","text":"For supernodal Cholesky factorizations, SupernodalMatrix stores the output of selinv. This subtype of AbstractMatrix allows for a more efficient memory access tailored to supernodal representations.","category":"page"},{"location":"supernodal_matrix/","page":"SupernodalMatrix","title":"SupernodalMatrix","text":"While you can just use it like a regular AbstractMatrix (i.e. you can get its size and index into it as you would expect), you might be interested in more specialized methods.","category":"page"},{"location":"supernodal_matrix/#Fields-and-construction","page":"SupernodalMatrix","title":"Fields and construction","text":"","category":"section"},{"location":"supernodal_matrix/#SelectedInversion.SupernodalMatrix","page":"SupernodalMatrix","title":"SelectedInversion.SupernodalMatrix","text":"SupernodalMatrix\n\nRepresents a sparse block lower triangular matrix with a supernodal layout. A supernode is a set of contiguous columns with identical sparsity pattern below the triangular block at the top. For each supernode, the corresponding nonzero entries are stored in a dense chunk. This enables us to use BLAS for operations on these chunks, so we combine the strengths of sparse and dense matrices.\n\nFields\n\nN::Int: Number of rows\nM::Int: Number of columns\nn_super::Int: Number of supernodes\nsuper_to_col::Vector{Int}: Start/end column of each supernode.                              Length n_super + 1.\ncol_to_super::Vector{Int}: Maps each column to its supernode index.                              Length M.\nsuper_to_vals::Vector{Int}: Start/end indices of each supernode into vals.                               Length n_super + 1.\nsuper_to_rows::Vector{Int}: Start/end indices of each supernode into rows.                               Length n_super + 1.\nvals::Vector{Float64}: Nonzero values.\nrows::Vector{Int}: Row indices. CAREFUL: These are zero-indexed!\nmax_super_rows::Int: Maximum number of rows below the triangular block in a                        supernode chunk.\ntransposed_chunks::Bool: Whether to store the transpose of chunks, such that                            the first axis in the chunk corresponds to the                            columns in the supernode.\nsymmetric_access::Bool: Whether to enforce symmetry when accessing entries.\ninvperm::Vector{Int}: Permutation to apply before accessing entries                         when depermuted_access == true.\ndepermuted_access::Bool: Whether to apply an inverse permutation before                            accessing entries.\n\n\n\n\n\n","category":"type"},{"location":"supernodal_matrix/#SelectedInversion.SupernodalMatrix-Tuple{SparseArrays.CHOLMOD.Factor}","page":"SupernodalMatrix","title":"SelectedInversion.SupernodalMatrix","text":"SupernodalMatrix(\n    F::SparseArrays.CHOLMOD.Factor;\n    transpose_chunks = false,\n    symmetric_access = false,\n    depermuted_access = false,\n)\n\nConstruct a SupernodalMatrix from a supernodal Cholesky factorization.\n\nKeyword arguments are explained in the SupernodalMatrix docstring.\n\n\n\n\n\n","category":"method"},{"location":"supernodal_matrix/#Methods","page":"SupernodalMatrix","title":"Methods","text":"","category":"section"},{"location":"supernodal_matrix/#SelectedInversion.val_range","page":"SupernodalMatrix","title":"SelectedInversion.val_range","text":"val_range(S::SupernodalMatrix, sup_idx::Int)\n\nGet the range of indices of supernode sup_idx into S.vals.\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.col_range","page":"SupernodalMatrix","title":"SelectedInversion.col_range","text":"col_range(S::SupernodalMatrix, sup_idx::Int)\n\nGet the range of columns of supernode sup_idx.\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.get_rows","page":"SupernodalMatrix","title":"SelectedInversion.get_rows","text":"get_rows(S::SupernodalMatrix, sup_idx::Int)\n\nGet the row indices corresponding to supernode sup_idx. CAREFUL: These are zero-indexed!\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.get_row_col_idcs","page":"SupernodalMatrix","title":"SelectedInversion.get_row_col_idcs","text":"get_row_col_idcs(S::SupernodalMatrix, sup_idx::Int)\n\nGet the row and column indices corresponding to supernode sup_idx. Both sets of indices are one-indexed.\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.get_max_sup_size","page":"SupernodalMatrix","title":"SelectedInversion.get_max_sup_size","text":"get_max_sup_size(S::SupernodalMatrix)\n\nGet the maximum number of columns of any supernode.\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.get_Sj","page":"SupernodalMatrix","title":"SelectedInversion.get_Sj","text":"get_Sj(S::SupernodalMatrix, sup_idx::Int)\n\nGet the row indices below the triangular block of supernode sup_idx. CAREFUL: These are zero-indexed!\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.partition_Sj","page":"SupernodalMatrix","title":"SelectedInversion.partition_Sj","text":"partition_Sj(S::SupernodalMatrix, Sj)\n\nPartition the output of get_Sj into contiguous subsets where each subset is fully contained in one supernode.\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.get_chunk","page":"SupernodalMatrix","title":"SelectedInversion.get_chunk","text":"get_chunk(S::SupernodalMatrix, sup_idx::Int)\n\nGet the dense chunk corresponding to supernode sup_idx. Includes the triangular block at the top.\n\n\n\n\n\n","category":"function"},{"location":"supernodal_matrix/#SelectedInversion.get_split_chunk","page":"SupernodalMatrix","title":"SelectedInversion.get_split_chunk","text":"get_split_chunk(S::SupernodalMatrix, sup_idx::Int)\n\nGet the chunk corresponding to supernode sup_idx, split into the diagonal / lower triangular block at the top, and the remaining block below it.\n\n\n\n\n\n","category":"function"},{"location":"#SelectedInversion","page":"Home","title":"SelectedInversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quickly compute selected entries of the inverse of a sparse matrix.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sparse matrices are one of the pillars of scientific computing. Sparse factorization methods allow us to solve linear systems involving the inverse efficiently. But in some applications, we might need a bunch of entries of the inverse. Selected inversion algorithms efficiently compute those entries of the inverse that correspond to non-zero entries in the factorization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SelectedInversion.jl directly interfaces with CHOLMOD-based Cholesky factorizations, which are the default for sparse symmetric positive-definite matrices in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SelectedInversion.jl is not yet a registered Julia package. Until it is, you can install it from this GitHub repository. To do so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Download Julia (>= version 1.10).\nLaunch the Julia REPL and type ] add https://github.com/timweiland/SelectedInversion.jl. ","category":"page"},{"location":"#SelInv-API","page":"Home","title":"SelInv API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Make sure to also check the Tutorial.","category":"page"},{"location":"#SelectedInversion.selinv","page":"Home","title":"SelectedInversion.selinv","text":"selinv(A::SparseMatrixCSC; depermute=false)\n    -> @NamedTuple{Z::AbstractMatrix, p::Vector{Int64}}\n\nCompute the selected inverse Z of A. The sparsity pattern of Z corresponds to that of the Cholesky factor of A, and the nonzero entries of Z match the corresponding entries in A⁻¹.\n\nArguments\n\nA::SparseMatrixCSC: The sparse symmetric positive definite matrix for which                       the selected inverse will be computed.\n\nKeyword arguments\n\ndepermute::Bool: Whether to depermute the selected inverse or not.\n\nReturns\n\nA named tuple Zp. Zp.Z is the selected inverse, and Zp.p is the permutation vector of the corresponding sparse Cholesky factorization.\n\n\n\n\n\nselinv(F::SparseArrays.CHOLMOD.Factor; depermute=false)\n    -> @NamedTuple{Z::AbstractMatrix, p::Vector{Int64}}\n\nCompute the selected inverse Z of some matrix A based on its sparse Cholesky factorization F.\n\nArguments\n\nF::SparseArrays.CHOLMOD.Factor:       Sparse Cholesky factorization of some matrix A.       F will be used internally for the computations underlying the       selected inversion of A.\n\nKeyword arguments\n\ndepermute::Bool: Whether to depermute the selected inverse or not.\n\nReturns\n\nA named tuple Zp. Zp.Z is the selected inverse, and Zp.p is the permutation vector of the corresponding sparse Cholesky factorization.\n\n\n\n\n\n","category":"function"}]
}
